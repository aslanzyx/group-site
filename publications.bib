@misc{evans2022mcbeth,
  archiveprefix = {arXiv},
  author        = {Evans, Aidan and Omonije, Seun and Soulé, Robert and Rand, Robert},
  title         = {MCBeth: A Measurement Based Quantum Programming Language},
  doi           = {arXiv.2204.10784},
  eprint        = {2204.10784},
  primaryclass  = {cs.PL},
  url           = {https://arxiv.org/abs/2204.10784},
  abstract      = {Gate-based quantum programming languages are ubiquitous but measurement-based languages currently exist only on paper. This work introduces MCBeth, a quantum programming language which allows programmers to directly represent, program, and simulate measurement-based and cluster state computation by building upon the measurement calculus. While MCBeth programs are meant to be executed directly on hardware, to take advantage of current machines we also provide a compiler to gate-based instructions. We argue that there are clear advantages to measurement-based quantum computation compared to gate-based when it comes to implementing common quantum algorithms and distributed quantum computation.},
  year          = {2022}
}

@inproceedings{hietala2021proving,
  title     = {{Proving Quantum Programs Correct}},
  author    = {Hietala, Kesha and Rand, Robert and Hung, Shih-Han and Li, Liyi and Hicks, Michael},
  year      = {2021},
  month     = {June},
  booktitle = {12th International Conference on Interactive Theorem Proving (ITP 2021)},
  editor    = {Cohen, Liron and Kaliszyk, Cezary},
  publisher = {{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}},
  address   = {Dagstuhl, Germany},
  series    = {Leibniz International Proceedings in Informatics (LIPIcs)},
  volume    = {193},
  eid       = {21},
  pages     = {21:1--21:19},
  doi       = {10.4230/LIPIcs.ITP.2021.21},
  url       = {https://github.com/inQWIRE/SQIR},
  abstract  = {As quantum computing progresses steadily from theory into practice, programmers will face a common problem: How can they be sure that their code does what they intend it to do? This paper presents encouraging results in the application of mechanized proof to the domain of quantum programming in the context of the SQIR development. It verifies the correctness of a range of a quantum algorithms including Grover's algorithm and quantum phase estimation, a key component of Shor's algorithm. In doing so, it aims to highlight both the successes and challenges of formal verification in the quantum context and motivate the theorem proving community to target quantum computing as an application domain.},
  keywords  = {formal verification, quantum computing, proof engineering},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}

@article{hietala2021verified,
  title         = {A Verified Optimizer for {{Quantum}} Circuits},
  author        = {Hietala, Kesha and Rand, Robert and Hung, Shih-Han and Wu, Xiaodi and Hicks, Michael},
  year          = {2021},
  month         = {January},
  journal       = {Proceedings of the ACM on Programming Languages},
  volume        = {5},
  number        = {POPL},
  eid           = {37},
  pages         = {37},
  numpages      = {29},
  doi           = {10.1145/3434318},
  archiveprefix = {arXiv},
  eprint        = {1912.02250},
  url           = {https://github.com/inQWIRE/SQIR},
  abstract      = {We present VOQC, the first fully verified optimizer for quantum circuits, written using the Coq proof assistant. Quantum circuits are expressed as programs in a simple, low-level language called SQIR, a simple quantum intermediate representation, which is deeply embedded in Coq. Optimizations and other transformations are expressed as Coq functions, which are proved correct with respect to a semantics of SQIR programs. SQIR uses a semantics of matrices of complex numbers, which is the standard for quantum computation, but treats matrices symbolically in order to reason about programs that use an arbitrary number of quantum bits. SQIR's careful design and our provided automation make it possible to write and verify a broad range of optimizations in VOQC, including full-circuit transformations from cutting-edge optimizers.},
  keywords      = {programming languages, formal verification, certified compilation, quantum computing, circuit optimization},
  webnote       = {POPL '21. See arXiv version for full paper with appendix.},
  bibsource     = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}

@misc{lehmann2022vyzx,
  author        = {Adrian Lehmann and Ben Caldwell and Robert Rand},
  title         = {{VyZX}: A Vision for Verifying the {ZX} Calculus},
  archiveprefix = {arXiv},
  doi           = {10.48550/ARXIV.2205.05781},
  url           = {https://arxiv.org/abs/2205.05781},
  eprint        = {2205.05781},
  primaryclass  = {quant-ph},
  abstract      = {Optimizing quantum circuits is a key challenge for quantum computing. The PyZX compiler broke new ground by optimizing circuits via the ZX calculus, a powerful graphical alternative to the quantum circuit model. Still, it carries no guarantee of its correctness. To address this, we developed VyZX, a verified ZX-calculus in the Coq proof assistant. VyZX provides two distinct representations of ZX diagrams for ease of programming and proof: A graph-based representation for writing high-level functions on diagrams and a block-based representation for proving ZX diagrams equivalent. Through these two different views, VyZX provides the tools necessary to verify properties and transformations of ZX diagrams. This paper explores the proofs and design choices underlying VyZX and its application and the challenges of verifying a graphical programming language.},
  year          = {2022}
}

@misc{marshall2021toward,
  title        = {Toward Formalizing the Q\# Programming Language},
  author       = {Marshall, Sarah and Singhal, Kartik and Hietala, Kesha and Rand, Robert},
  year         = {2021},
  month        = 5,
  howpublished = {18th International Conference on Quantum Physics and Logic 2021},
  url          = {https://ks.cs.uchicago.edu/publication/tfqpl/},
  abstract     = {Q\# is a high-level programming language from Microsoft for writing and running quantum programs. Like most industrial languages, it was designed without a formal specification, which can naturally lead to ambiguity in its interpretation. We aim to provide a formal specification and semantics for Q\#, placing the language on a solid mathematical foundation, enabling further evolution of its design and type system, and leading to research in program correctness and verified compiler implementation. This poster describes our current progress and outlines the next steps.},
  keywords     = {quantum computing, quantum computation, programming languages, formal specification, formal language definitions, type systems, semantics and reasoning, quantum programming languages, language design, q\#},
  note         = {Extended abstract accepted to QPL 2021 for the Poster Session.}
}

@inproceedings{rand2021extending,
  title     = {Extending Gottesman Types Beyond the Clifford Group},
  author    = {Rand, Robert and Sundaram, Aarthi and Singhal, Kartik and Lackey, Brad},
  year      = {2021},
  month     = 6,
  booktitle = {Second International Workshop on Programming Languages for Quantum Computing (PLanQC '21)},
  url       = {https://rand.cs.uchicago.edu/publication/rand-2021-extending/},
  abstract  = {We extend our previous work on Gottesman Types to cover circuits beyond Clifford Group and introduce the notion of linear combination types.},
  keywords  = {quantum computing, type systems, gottesman types}
}

@inproceedings{singhal2021toward,
  title     = {Toward a Type-Theoretic Interpretation of Q\# and Statically Enforcing the No-Cloning Theorem},
  author    = {Singhal, Kartik and Marshall, Sarah and Hietala, Kesha and Rand, Robert},
  year      = {2021},
  month     = 6,
  booktitle = {Second International Workshop on Programming Languages for Quantum Computing (PLanQC '21)},
  url       = {https://ks.cs.uchicago.edu/publication/tttiq/},
  abstract  = {Q\# is a high-level programming language from Microsoft for writing and running quantum programs. Like most industrial languages, it was designed without a formal specification, which can naturally lead to ambiguity in its interpretation. Further, currently, the Q\# type system cannot statically prevent cloning of qubits. We aim to provide a formal specification and semantics for Q\#, placing the language on a solid mathematical foundation, enabling further evolution of its design and type system (including enforcing no-cloning). This paper describes our current progress in designing λ-Q\# (an idealized version of Q\#), our solution to the qubit cloning problem in λ-Q\#, and outlines the next steps.},
  keywords  = {quantum computing, quantum computation, programming languages, formal specification, formal language definitions, type systems, semantics and reasoning, quantum programming languages, language design, q\#}
}

@misc{singhal2022algorithmic,
  title    = {Q\# as a Quantum Algorithmic Language},
  author   = {Singhal, Kartik and Marshall, Sarah and Hietala, Kesha and Rand, Robert},
  year     = {2022},
  month    = 2,
  url      = {https://ks.cs.uchicago.edu/publication/q-algol/},
  abstract = {Q\# is a standalone domain-specific programming language from Microsoft for writing and running quantum programs. Like most industrial languages, it was designed without a formal specification, which can naturally lead to ambiguity in its interpretation. We aim to provide a formal language definition for Q\#, placing the language on a solid mathematical foundation and enabling further evolution of its design and type system. This paper presents λ-Q\#, an idealized version of Q\# that illustrates how we may view Q\# as a quantum Algol (algorithmic language). We show the safety properties enforced by λ-Q\#'s type system and present its equational semantics based on a complete algebraic theory by Staton.},
  keywords = {quantum computing, quantum computation, programming languages, formal specification, formal language definitions, type systems, semantics and reasoning, quantum programming languages, language design, q\#},
  note     = {Under review.}
}

@misc{sundaram2022rich,
  title         = {A Rich Type System for Quantum Programs},
  author        = {Aarthi Sundaram and Robert Rand and Kartik Singhal and Brad Lackey},
  year          = {2022},
  month         = 2,
  archiveprefix = {arXiv},
  eprint        = {2101.08939},
  abstract      = {We show that Gottesman's [1998] semantics for Clifford circuits based on the Heisenberg representation can be treated as a type system that can efficiently characterize a common subset of quantum programs. Our applications include (i) certifying whether auxiliary qubits can be safely disposed of, (ii) determining if a system is separable across a given bi-partition, (iii) checking the transversality of a gate with respect to a given stabilizer code, and (iv) typing post-measurement states for computational basis measurements. Further, this type system is extended to accommodate universal quantum computing by deriving types for the T-gate, multiply-controlled unitaries such as the Toffoli gate, and some gate injection circuits that use associated magic states. These types allow us to prove a lower bound on the number of T gates necessary to perform a multiply-controlled Z gate.},
  keywords      = {quantum computing, type systems, gottesman types},
  note          = {Under review. A previous version accepted as a poster at the 25th Annual Conference on Quantum Information Processing (QIP 2022).}
}

@misc{voichick2022qunity,
  archiveprefix = {arXiv},
  author        = {Voichick, Finn and Rand, Robert and Hicks, Michael},
  title         = {Qunity: A Unified Language for Quantum and Classical Computing},
  doi           = {arxiv.2204.12384},
  url           = {https://arxiv.org/abs/2204.12384},
  eprint        = {2204.12384},
  primaryclass  = {cs.PL},
  abstract      = {We introduce Qunity, a new quantum programming language designed around the central goal of treating quantum computing as a natural generalization of classical computing. Qunity presents a unified syntax where familiar programming constructs can have both quantum and classical effects. For example, one can use sum types to implement the direct sum of linear operators, exception handling syntax to implement projective measurements, and aliasing to induce entanglement. Further, Qunity takes advantage of the overlooked BQP subroutine theorem, allowing one to construct reversible subroutines from irreversible quantum algorithms through the uncomputation of "garbage" outputs. Unlike existing languages that enable quantum aspects with a separate add-on (e.g., gates added to a classical language), we unify quantum and classical computing through novel compositional semantics based on Kraus operators. We present Qunity's syntax, type system, and denotational semantics, showing how it can cleanly express several quantum algorithms. We also outline how Qunity could be compiled to OpenQASM, demonstrating the realizability of our design.},
  year          = {2022}
}

@misc{zweifler2021formal,
  title        = {Formal Verification of Gottesman Semantics},
  author       = {Zweifler, Jacob and Rand, Robert},
  year         = {2021},
  month        = 5,
  howpublished = {18th International Conference on Quantum Physics and Logic 2021},
  url          = {https://rand.cs.uchicago.edu/publication/zweifler-2021-formal/},
  keywords     = {quantum computing, formal verification, gottesman types},
  note         = {Extended abstract accepted to QPL 2021 for the Poster Session.}
}
